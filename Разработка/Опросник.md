0. Полиморфиз
Возможность одногообразного обращения к разным типам данных объедененым общей
частью наследования, или имлиментацией интерфейсов.

1. Enums
тип, значения которого ограничены конечным набором констант. Конструктор может 
быть либо приватным, либо package-private. Значения констант объявляются в начале
класса. Каждая из них может содержать так же имплементацию абстрактных методов
или содержать значения переменных.

2. Beans
Beans — классы в языке Java, написанные по определённым правилам:
- Класс должен иметь конструктор без параметров, с модификатором доступа public.
- Доступн к полям через get и set методы, называющиеся в соответствии с
  соглашением об именах.
- Класс должен быть сериализуем

3. Порядок вызова
public void test() { new X(); }

class Y {
    { out.print(0); }
    Y() { out.print(1); }
}

class X extends Y {
    { out.print(2); }
    X() { out.print(3); }
}

> 0123

private int x = 1;
{ out.print(x); out.print(y); }
private int y = 2;

> Compilation error: illegal forward reference.

2. String, StringBuilder, StringBuffer
String - threadsafe, immutable, создает новый instance при модификации
StringBuffer - threadsafe (работает медленнее)
StringBuilder - not threadsafe (работает быстрее).

3. Overriding/Overloading
Overriding - изменяет поведение метода суперкласса (аннтоацию @Override).
Overloading - дополняет поведение суперкласса новым методом.

4. Список аргументов переменной длины
Реализуется через массив аргуметов (так же может быть использовано сокращенная
аннотация void method(Object... args) { ... } )

4. Модификаторы
transient - исключает из сериализации (используется в Hibernate для исключения
из авто построения схемы)
volatile - отключает копирование примитивов и ссылок в автономные потоки при
этом чтение и запись в такие переменные не явным способом синхронизированы
strictfp - указывает на то, что значение float и double будет одинаковым вне
зависимости от платформы

6. Работа с памятью 
Примитивы хранятся в стеке
Объекты в куче

Каждый поток делает себе копию примитивов и ссылок, если это не блокируется 
модификатором volatile 

7. Сборщик мусора

Собирает мусор  
Cхема
- counter (Медленный, не используется в JVM, фрагментация) - с каждым объектом 
храниться счетчик ссылок на него. Когда он равен 0 - объект убирается из памяти. 
Решение задачи циклических ссылок является ресурсоемкой операцией. 
- copy (необходимы остановки, затраты памяти) - останавливает приложение и 
копирует все объекты на которые есть активные ссылки из одной кучи в другую, 
старую кучу удаляем. 
- mark&sweap - похожа на предыдущую но копирует в конце процесса сканирования, 
что дефрагментация памяти, и уплотнение долго живущие ссылки копятся в начале 
памяти и реже перезаписываются.
Поколения:
Зачистка может проходить как для всей кучи так и для секторов разделенных по 
поколениям, таким образом новые объекты которые чаще удаляются если остаются 
при чистке копируются в другой сектор пока не переходят в старые объекты которые
проверяются реже.
Потоки:
Так же различают однопоточные и многопоточные режимы сборки, однопоточные 
эффективней по испольованию памяти а многопоточные по скорости.

Запросить не принудительный запуск сборщика можно System.gc()

8. Equals и hashCode
По нормам программирования и за исключением колизий должны всегда выдавать
одинаковые результаты сравнения через hashCode и equals методы. В противном
случаи могут быть проблемы при работе с колекциями и другими базовыми классами.

9. Ссылки
- Strong Reference - стандартный механизм обращение к объектам.
Далее идут имплементации Reference объект получается через метод get. Надо 
понимать что не взависимости от программы этот метод может вернуть null, если 
сборщик мусора уже удалил объект
- SoftReference - new SoftReference<XClass>(new XClass()); 
get() вернёт null, если осталось мало памяти и вероятен OutOfMemoryError. Такие
ссылки удобны для кеширования объектов.
- WeakReference - new WeakReference<XClass>(new XClass());
get() вернёт null, если GC решил что лучше удалить этот объект.
- PhantomReference - new PhantomReference<XClass>(new XClass(), queue);
get() всегда возвращает null, ссылка попадёт в очередь после физ удаления.
Сам объект из памяти удалён не будет вплоть до вызова на ссылке clear();

10. Поведение сборщика муслора при работ с фантомной ссылкой
- Выполняется финалайз
- Если после этого небыло создано внешних ссылок на этот объект то он будет
удален а ссылка отправится в очередь.

10. Утечки памяти
Опасность использования глобальных карт или колекций в глобалных объектах.

1. Collections

Корневые интерфейсы 
--------------------------------------------------------------------------------
Iterable - Collection - Set - SortedSet - NavigableSet 
                      - Queue - Deque
                      - List
Map
    
--------------------------------------------------------------------------------
Листы 
Существуют два основных типа реализации:
- LinkedList (связаные ячейки): имеет ссылки в обе стороны.
- ArrayList (массив): копирует на расширении, хранит элементы последовательно.
  не осовобождает автоматически место



- Collection
    - List хранят с указаным порядком произвольный набор элементов (для 90% ArrayList быстрей LinkedList)
        - ArrayList использует массивов для хранение (данные хранятся подряд, обычно размер массива в начале 10)
            - расширяется по мере увеличения списка
            - можно задать размер
            - быстрый доступ, долгая запись, долгое удаление
            - после удаления не уменьшается до вызова trimToSize() 
        - LinkedList на основе связаных элементов (данные хранятся в оболочках которые указывают на соседнии элементы)
            - быстрый последовательный доступ
            - быстрое удаление из центра
            - медленый случайный доступ
    - Set хранят без порядка 
        - HashSet (состоит из bucket'ов)
            - средняя запись и чтения
            - использует hash для сравнения
        - TreeSet (SortedSet)
            - хранит элементы отсорированые для выборки (черно красное дерево)
            - оптимальное чтение
            - умеет сам себя балансировать
        - LinkedHashSet
            - оптимальная запись
            - хранит элменты в порядке добавления
            - использует hash для сравнения
        - EnumSet
    - Queue очереди хранят в зависимости от алгоритма работы очереди.
        - PriorityQueue 
            - порядок может управлятся при задании Comparator
        - LinkedList
        - ArrayDeque 

- Map
    - HashMap (в начале 16 корзин, максимальное число значений 2^32)
        - использует хеши ключей для сравнения
        - использует корзины для поиска
    - Hashtable
        - испльзует хеши ключей для сравнения 
    - TreeMap
        - хранит ключи остортированными
    - LinkedHashMap
        - хранит ключи в порядке вставки
    - WeakHashMap
        - удаляет объекты если 
    - EnumMap


3. Inner classes
Внутренний класс - класс, который объявлен внутри другого класса, например:

public class Outer {
    private class Inner {
    }
}

Доступ к статическому - new OuterClass.StaticNestedClass;
Доступ к нестатическому - outerObject.new InnerClass();

4. Наследование от внутренних классов
Если класс не статик необходимо передать внутрь объект класса контейнера и
вызвать из него конструктор.

class WithInner {
   class Inner {}
}

public class InheritInner extends WithInner.Inner {
   // !!! InheritInner() {}  - не скомпилится !!
   InheritInner(WithInner wi) { wi.super(); }
}

5. Аннонимный класс
Анонимный внутренний класс - это класс, определенный в методе. Так же они 
являются замыканиями.

InterfaceName variable = new InterfaceName() { ...implimentation... };

6. ORM
Object-relational mapping — технология программирования, которая связывает
базы данных с концепциями объектно-ориентированных языков программирования.

7. JPA
Java Persistence API - стандарт/технология, обеспечивающая объектно-реляционное
отображение простых объектов и предоставляющая API для сохранения, получения и
управления такими объектами (часть EJB3). Только описывает интерфейс
взаимодействия, реализации стороние.

Реализации JPA:
- Hibernate
- TopLink
- EclipseLink
- OpenJPA

Состоит из следующих частей (javax.persistance)
- Entity manager API позволяет организовать взаимодействие с ORM провайдером.
- JPQL – объектный язык запросов. Похож на SQL, но запросы относятся объектам.
- Criteria API обеспечивает выполнение запросов без JPQL, а через объекты. 
- Metadata – набор XML/аннотаций, которыми мы описываем метаданные связей
             объекта с таблицами базы данных.

8. EntityManager and EntityManagerFactory
EntityManager - not thread-safe
EntityManagerFactory - thread-safe

Но не смотря на это в Spring IoC хорошим тоном является использовать инъекцию
менеджера место фабрики так как он будет создавать новый объект для каждого
запроса.

1. Cуть паттерна DI или IoC
Dependency injection (DI или Inversion of Control IoC) - это способ достижения
слабой связанности, он предоставляет возможность объекту получать ссылки на свои
зависимости. Применение данного подхода позволяет убрать из объекта код связаный
с инициализацией используемых им объектов, что позволяет гибко подменять разные
имплиментации.

2. IoC контейнеры
Spring, guice. + Есть стандарт аннотаций в JSR.

3. Виды DI
Конструкторы, сеттеры. А так же современные контейнеры умеют производить
инъекцию в приватные поля без существования сеттеров или конструктора.

4. Spring
Spring - фреймворк основной функцией которого является DI, но так же в нём
присутствуют множество дополнительных модулей.

4.1 Состовные части Spring Framework
Spring-core - фабрика бинов позволяющая создавать объекты на основе описаных DI.
Spring-context - контроль жизненого цикла объекта. JNDI, EJB, I18N, Validation. 
Spring-aop - интеграция с AOP framework'ами и своё решение. AOP-Proxing,
             позволяет производить DI не конечных объектов, а пустых заглушек
             (это нужно когда объект ещё не существует). 
Spring-dao - в основном упаковывает исключения JDBC. 
Spring-orm - интеграция ORM framework'ов (Hibernate, iBatis), шаблонные функции.
Spring-wev - context web-приложений.
Spring-mvc - MVC в основном для JSP страниц.

Spring-jms - упрощение работы с JMS.
Spring-test - контейнер для тестов, движок jUint.
Spring-security - средства для управления доступом.
Spring-social - интеграция с соц сетями.
Spring-web-flow - для пострание онлайн визардов (форм из нескольких страниц)
Spring-batch - средства для обработки большого количество записей в потоковых
               приложениях.

5. AOP
Аспектно-ориентированное программирование (АОП) — парадигма, основанная на идее
разделения функциональности для улучшения разбиения программы на модули. 

Основные понятия АОП:
- Aspect — модуль/класс реализующий сквозную функциональность. 
- Advice — код(обычно метод) добавляемый в point cut при выполнении aspect.
- Join point — точка в выполнении, где следует применить advice.
- Pointcut — набор join point'ов. Абстрактное определение надо ли здесь
             выполнить advice. 

- Introduction — изменение класса для добавления aspect'ов. (Как правило PROXY)

6. Принцип Работы BeanFactory
BeanFactory - имя данные о классах и их зависимостях в приложении создаёт
объекты, производя DI.

7. В чем роль ApplicationContext в Spring?
Application Context - это контейнер, предоставляет функционал BeanFactory,
а так же: 

- Контроль жизенего цикла
- Интернационализация
- События для бинов, которые зарегестрированы как слушатели.

8. Spring ORM/DAO
Класс HibernateDaoSupport содержит методы для получения сессии или фабрики
сессий, а так же предоставляет Template объекты оборачивающие исключения.

9.Id generator в Hibernate?

Increment - генератор уникальных long, short или int. (not thread safe)
Identity - использует генератор базы данных, создает long, short или int. 
Sequence - использует последовательности, создает long, short или int.
Hilo - использует алгоритм hi/lo, long, short или int. (уникальны в данной базе)
Seqhilo - как и Hilo, но уникальны для набора баз данных.
Uuid - использует алгоритм 128-bit UUID. Идентификатор уникальный в данной сети.
Guid - использует сгенерированую БД строку GUID в (MS SQL Server и MySQL).
Native - руководствуется стандартным методом для данной базы данных.
assigned - ручная установка.
Select - получает ключ, присвоенный триггером.
Foreign - использует идентификатор другого, объекта. (для <one-to-one>)

10. Реализция класса используя Spring
- Созадние интерфейс, описывающий функционал (Нужен для проксирования)
- Реализация класса
- Конфигурация зависимостей (XML/Аннотации)

11. Добавление поддержки Spring в web-приложение
Достаточно указать ContextLoaderListener в web.xml, возможно так же указать
список загружаемых конфигурационных файлов:

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/xyz.xml</param-value>
        </context-param>
    </listener-class>
</listener>

12. Настройка соединение с БД в Spring
Используя datasource при этом можно указать параметры явно в файле настроек либо
использовать JNDI, указав путь до объекта доступа к данным.

13. Преимущства использования Hibernate
- Язык запросов не привязаный к БД (HQL) 
- Возможность производить запросы на базе Criteria API
- Преобразование результатов запроса в объекты
- Подгрузка данных по мере работы с ними (Lazy loading)
- Cash
- Автоматической сохрание изменений объекта (возможность настройки)

14. Session / Session factory в Hibernate.
SessionFactory - это thread safe объект для получения session объектов из 
                 имеющихся настроек.
Session - объект обеспечить механизмы создания, чтения и удаления для объектов
          связаных с базой данных. Такие объекты могут быть в трёх состояниях:

15. Состояния объектов связываемых с Hibernate Session 
transient - не привзяаные к сессии (не имеет никакой связи с Hibernate)
persistent - привязаные к сессии (изменения будут созранятся)
detached - отвязаные о сессии, но раньше были привязаны
           (связь с Hibernate разорвана, изменения не будут сохранятся)


16. Методы работы с Session в Hibernate
------------------------

17. Различие методов get() и load()
Load - если запрос вернул 0 записей вызовет исключение.
Get - если запрос вернул 0 записей вернет null. 

18. Типы управления транзакциями в Hibernate
- ручное управление
- управляемые транзакции (осуществляет JTA) 
- не управляемые транзакции (осуществляет контейнер)

19. Lazy loading
Lazy loading - загрузка объекта (связаного с основным объектом запроса) при
первом обращении к его данным. Главное ограничени что объект должен быть 
присоединён к открытой сессии.

20. Стратегии загрузки объектов в Hibernate
--------------------------
- Join - получение ассоциированных объектов и коллекции используя OUTER JOIN
- Select - использует уточняющий SELECT чтобы получить ассоциированные объекты
и коллекции. Если вы не установите lazy fetching определив lazy="false",
уточняющий SELECT будет выполнен только когда вы запрашиваете доступ к
ассоциированным объектам
- Subselect fetching: поведение такое же, как у предыдущего типа, за тем
исключением, что будут загружены ассоциации для все других коллекций,
«родительским» для которых является сущность, которую вы загрузили
первым SELECT’ом.
- Batch fetching: оптимизированная стратегия вида select fetching. Получает
группу сущностей или коллекций в одном SELECT’е.

21. Типы кэша в Hibernate
-----
Первый уровень - основан на сессии и хранящий в ней информации об объектах. 
                 Так же он используется при генерации Update'ов.
Второй уровень - основан на перехвате запросов и их отправе во внешие средства
                 кеширования.

22. Средства кеширования для второго уровня
EHCache, OSCache, SwarmCache, JBoss TreeCache

23. Стратегий кеширования
--------
Read-only - работает только на получение данных из базы данных.
Read/write - так же используется и для обновления
Нестрогий read/write - не гарантирует, что две транзакции не модифицируют
                       одни и те же данные синхронно.
Transactional - полноценное кэширование транзакций. (Доступно в JTA окружении)

24. Разница между сортированными и упорядоченными коллекциями в Hibernate
Сортированные коллекции отсортированы используя java comparator
Упорядоченные коллекции по средствам запроса 

25. Типы локов
ReentrantLock
ReadWriteLock

25. JMS Persistance 
Гарантия что сообщени не будет потеряно при падении очереди.

27. JMS Durability
Гарантия что сообщение будет получено подпищиком если он уже был подключен к 
подписке и временно отключался.

28. SOLID 
При расширении должен быть только один мотив.
Расширение лучше чем изменение.
Дополнение лучше чем замена
Не должно быть элементов которые используются не во всех имплементациях
Абстракции не должны зависеть от деталей но детали должны зависеть от абстракций 

29. Остановка программы
Программа заканчивается когда все потоки будут закончены, при этом окончание будет
вызвано даже если в программе остались потоки демоны.

30. Timer
Позволят запустить поток через n миллисекунд.

31. Семафоры и контроль потоков
Semaphore
CountdownLatch
CyclicBarrier
Exchanger
(Muttex?)

32. Патерны
- Chain of Responsibility - посылает по очереди во все обработчики пока не будет
принято.
- Command - упаковывает параметры
- Interpreter - решает какой обработчики будет задействован
- Iterator - предоставляет по очереди элементы из множества без связи к типу
контейнера
- Mediator - упаковывает объект с знанием как с ним работать
- Memento - коприрует часть объекта для познейшего обращения к предыдущим состояниям
- Observer - контролирует состояние объекты и при смене оповещает подпищиков
- State - меняет состояние объекта в зависимости от его состояния
- Strategy - переносит логику с которой будет происходить вызываемое действие.
- Visitor - содержить разные обработчики для разных присланых пользователей
- Template Method - описывает процесс состоящий из абстрактных операций.
- Adapter - адаптирует один интерфейс для использования объектом расчитывающим на
другой интерфейс
- Bridge/Handle/Body - разделяет структуру абстракции и реализация
- Composite - собирает интерфейсы вместе
- Decorator/Wrapper - оборачивает обект добовляя функциональность
- Facade - предоставляет общий интерфейс для блока.
- Singleton - существует в единственном числе
- Prototype - объект служащий шаблоном для копирования
- Factory Method - создаёт объект
- Abstract Factory - создаёт класс но не указывает на реализацию
- Builder - Создаёт внешние объекты.
- Proxy - создаёт подделку объекта чтоб управлять доступом к нему
- Flyweight - имитирует существование разных малых объектов, которых на самом деле нет.

33. SQL
- объеденение таблиц union all
- хранимая процедура — набор SQL-инструкций хранимые на сервере
- Transact-SQL содержит следующие ранжирующие функции:
-- RANK(выдаёт индекс первого элемента группы),
-- NTILE(выдаёт в какой сектор попало значение после сортировки),
-- DENSE_RANK(выдаёт индекс группы),
-- ROW_NUMBER(выдаёт индес строки)
- APPLY даёт возможность применить значение для каждой строки выборки
- Транзакция подчинается - ACID - atomicity(атомарность), consistency(непротиворечивость),
isolation(изолированность), durability(устойчивость).
- ROLLUP, CUBE и GROUPING SETS - групируют части строк для разных комбинаций
- Distinct избегает повторения значения стрки дважды или одного значения в колонки
- COUNT(*), COUNT, SUM, AVG, MIN, MAX - функции сборки
- DDL (Определение), DML (Работа), TCL (Транзакции), DCL(Контроль)
